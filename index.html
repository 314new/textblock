<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0">

  <title>textblock.js</title>
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,700" rel="stylesheet">
  <link rel="stylesheet" href="textblock.css">

  <script src="src/textblock.js"></script>

  <!-- Edit this JSON code to scale text elements. -->

  <script>
    Textblock([
      {
        target:'h1, h2, h3, p, ul li',
        minFontSize: 1.5,
        maxFontSize: 2.2,
        minLineHeight: 1.4,
        maxLineHeight: 1.3,
        container: 'self'
      },{
        target:'.code',
        minFontSize: 1.2,
        maxFontSize: 1.8,
        minLineHeight: 1.5,
        maxLineHeight: 1.4,
        container: 'self'
      }
    ]);
  </script>

  <!-- / -->






</head>
<body>

  <div id="content">

      <h1>textblock.js</h1>

      <p class="subtitle"><em>Responsive Web Type</em></p>

      <p>Those of us who worked through the 90s know that what the web lacked in options gave us license to make some pretty awful websites. Bad typesetting was the norm because we literally had only a handful of system fonts to work with. The entire web was either Helvetica, Lucida, or Georgia. And mailbox dog.</p>

      <p>Today it would seem we have all of what’s needed to set perfect type, but following the standards still leads to a compromise. Why is it that in this age of computerized design and production our web typography lacks so much?</p>

      <p>CSS Breakpoints are good for some things but setting type isn’t one of them. Using breakpoints to set responsive type is like driving a car with square wheels. It might get you there but the ride will be bumpy. They have a <em>thunking</em> effect across widths. Of course the more breakpoints you add, the better the ride, but it also makes the code more complex. It’s a compromise either way.</p>

      <p>When my shop decided to switch to code earlier in the design process, we tried ditching the standards for a minute. The idea was to make fully responsive layouts with perfectly set type that was true to the design. No compromises.</p>

      <p>The result was perfect and we did it by applying inline CSS with JS. The intention was to replace that code with the standard, compliant CSS but we never did. That “prototype” stage is now what we take live. In most cases the code is lighter than a “fully compliant” CSS implementation with all the breakpoints and such. But it’s not all rule breaking because this code can sit on top of a page’s CSS.</p>

      <p>We call it textblock.js. This page is set with it. Resize the browser to see it work.</p>

      <h2>How it works</h2>

      <p>Textblock provides continuous responsive typesetting beyond standard CSS breakpoints. It adjusts type size and line height to set perfect type across varying screen widths. The script works on top of your current CSS, meaning you may already have a fallback.</p>

      <p>It uses minimum and maximum values for font size, leading (line height), and measure (the container width).</p>

      <p>The script calculates floating point values based on units defined within the document head (or foot):</p>

      <ul>
        <li>Minimum/maximum font size</li>
        <li>Minimum/maximum font leading (line height)</li>
        <li>Minimum/maximum container width</li>
      </ul>

      <p>For easy math set the root em to 10px so em units are base 10, i.e. 2.4em = 24px.</p>

      <h3>To initialize</h3>

      <div class="code">
        Textblock([{<br>
          &emsp;target:".some-element"<br>
        }]);
      </div>

      <h3>Mostly Optional Parameters</h3>

      <ul>
        <li><span class="inline-code">target</span>: The element that should be resized <span class="inline-code">".your-class p"</span>, <span class="inline-code">"#cool-id .another"</span> (required)</li>
        <li><span class="inline-code">minWidth</span>: default <span class="inline-code">280</span></li>
        <li><span class="inline-code">maxWidth</span>: default <span class="inline-code">800</span></li>
        <li><span class="inline-code">minFontSize</span>: default <span class="inline-code">1.9</span></li>
        <li><span class="inline-code">maxFontSize</span>: default <span class="inline-code">2.6</span></li>
        <li><span class="inline-code">minLineHeight</span>: default <span class="inline-code">1.33</span></li>
        <li><span class="inline-code">maxLineHeight</span>: default <span class="inline-code">1.25</span></li>
        <li><span class="inline-code">container</span>: The container width to measure. Defaults to <span class="inline-code">"parent"</span> and can alternatively be set to <span class="inline-code">"self"</span>.</li>
        <li><span class="inline-code">units</span>: default <span class="inline-code">"em"</span></li>
      </ul>

      <p>Example with extra parameters included</p>

      <div class="code">
        Textblock([{<br>
          &emsp;target:".some-class",<br>
          &emsp;minWidth: 280,<br>
          &emsp;maxWidth: 800,<br>
          &emsp;minFontSize: 1.9,<br>
          &emsp;maxFontSize: 2.6,<br>
          &emsp;minLineHeight: 1.33,<br>
          &emsp;maxLineHeight: 1.25,<br>
          &emsp;container: "self",<br>
          &emsp;units: "rem"<br>
        }]);
      </div>

      <h3>Multiple elements with different settings</h3>

      <div class="code">
        Textblock([<br>
          &emsp;{<br>
            &emsp;&emsp;target:".some-class",<br>
            &emsp;&emsp;minFontSize: 1.9,<br>
            &emsp;&emsp;maxFontSize: 2.6,<br>
          &emsp;},<br>
          &emsp;{<br>
            &emsp;&emsp;target:".another",<br>
            &emsp;&emsp;minFontSize: 2.4,<br>
            &emsp;&emsp;maxFontSize: 3.6,<br>
            &emsp;&emsp;container: "self"<br>
          &emsp;}<br>
        ]);
      </div>

  </content>

</body>
</html>
